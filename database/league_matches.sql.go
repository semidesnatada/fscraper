// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: league_matches.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createLeagueMatch = `-- name: CreateLeagueMatch :one
INSERT INTO league_matches (id, competition_id, home_team_id, away_team_id,
home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
)
RETURNING id, competition_id, home_team_id, away_team_id, home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url
`

type CreateLeagueMatchParams struct {
	ID            uuid.UUID
	CompetitionID uuid.UUID
	HomeTeamID    uuid.UUID
	AwayTeamID    uuid.UUID
	HomeGoals     int32
	AwayGoals     int32
	Date          time.Time
	KickOffTime   sql.NullTime
	RefereeID     uuid.NullUUID
	VenueID       uuid.NullUUID
	Attendance    sql.NullInt32
	HomeXg        sql.NullFloat64
	AwayXg        sql.NullFloat64
	Weekday       string
	Url           string
}

func (q *Queries) CreateLeagueMatch(ctx context.Context, arg CreateLeagueMatchParams) (LeagueMatch, error) {
	row := q.db.QueryRowContext(ctx, createLeagueMatch,
		arg.ID,
		arg.CompetitionID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.HomeGoals,
		arg.AwayGoals,
		arg.Date,
		arg.KickOffTime,
		arg.RefereeID,
		arg.VenueID,
		arg.Attendance,
		arg.HomeXg,
		arg.AwayXg,
		arg.Weekday,
		arg.Url,
	)
	var i LeagueMatch
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeGoals,
		&i.AwayGoals,
		&i.Date,
		&i.KickOffTime,
		&i.RefereeID,
		&i.VenueID,
		&i.Attendance,
		&i.HomeXg,
		&i.AwayXg,
		&i.Weekday,
		&i.Url,
	)
	return i, err
}

const deleteLeagueMatches = `-- name: DeleteLeagueMatches :exec
DELETE FROM league_matches
`

func (q *Queries) DeleteLeagueMatches(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLeagueMatches)
	return err
}

const getLeagueGamesByTeamAndSeason = `-- name: GetLeagueGamesByTeamAndSeason :many
SELECT 
HT.name as home_team, 
AT.name as away_team, 
M.home_goals as home_goals, 
M.away_goals as away_goals,
M.date as date,
venues.name as stadium
FROM league_matches as M
INNER JOIN teams as HT on HT.id = M.home_team_id
INNER JOIN teams as AT on AT.id = M.away_team_id
INNER JOIN competitions on competitions.id = M.competition_id
INNER JOIN venues on M.venue_id = venues.id
WHERE (HT.name = $1 OR AT.name = $1) AND competitions.name = $2 AND competitions.season = $3
`

type GetLeagueGamesByTeamAndSeasonParams struct {
	Name   string
	Name_2 string
	Season string
}

type GetLeagueGamesByTeamAndSeasonRow struct {
	HomeTeam  string
	AwayTeam  string
	HomeGoals int32
	AwayGoals int32
	Date      time.Time
	Stadium   string
}

func (q *Queries) GetLeagueGamesByTeamAndSeason(ctx context.Context, arg GetLeagueGamesByTeamAndSeasonParams) ([]GetLeagueGamesByTeamAndSeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeagueGamesByTeamAndSeason, arg.Name, arg.Name_2, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeagueGamesByTeamAndSeasonRow
	for rows.Next() {
		var i GetLeagueGamesByTeamAndSeasonRow
		if err := rows.Scan(
			&i.HomeTeam,
			&i.AwayTeam,
			&i.HomeGoals,
			&i.AwayGoals,
			&i.Date,
			&i.Stadium,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueMatches = `-- name: GetLeagueMatches :many
SELECT id, competition_id, home_team_id, away_team_id, home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url FROM league_matches
`

func (q *Queries) GetLeagueMatches(ctx context.Context) ([]LeagueMatch, error) {
	rows, err := q.db.QueryContext(ctx, getLeagueMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueMatch
	for rows.Next() {
		var i LeagueMatch
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeGoals,
			&i.AwayGoals,
			&i.Date,
			&i.KickOffTime,
			&i.RefereeID,
			&i.VenueID,
			&i.Attendance,
			&i.HomeXg,
			&i.AwayXg,
			&i.Weekday,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueMatchesByClub = `-- name: GetLeagueMatchesByClub :many
SELECT id, competition_id, home_team_id, away_team_id, home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url FROM league_matches
WHERE home_team_id = $1 or away_team_id = $1
`

func (q *Queries) GetLeagueMatchesByClub(ctx context.Context, homeTeamID uuid.UUID) ([]LeagueMatch, error) {
	rows, err := q.db.QueryContext(ctx, getLeagueMatchesByClub, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueMatch
	for rows.Next() {
		var i LeagueMatch
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeGoals,
			&i.AwayGoals,
			&i.Date,
			&i.KickOffTime,
			&i.RefereeID,
			&i.VenueID,
			&i.Attendance,
			&i.HomeXg,
			&i.AwayXg,
			&i.Weekday,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
