// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: p_m_verification.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const getAllPlayersAndSharedMinsByID = `-- name: GetAllPlayersAndSharedMinsByID :many
SELECT
    P.id AS other_player_id,
    SUM(CASE WHEN LEAST(OTHERS.last_minute, t_last_min) - GREATEST(OTHERS.first_minute, t_first_min)> 0 THEN LEAST(OTHERS.last_minute, t_last_min) - GREATEST(OTHERS.first_minute, t_first_min) ELSE 0 END) as shared_minutes
FROM (
SELECT
    match_id,
    at_home AS target_at_home,
    first_minute AS t_first_min,
    last_minute AS t_last_min
FROM player_matches
INNER JOIN players ON players.id = player_matches.player_id
WHERE players.id = $1
) AS GAMES_IN_SCOPE
INNER JOIN player_matches AS OTHERS ON (OTHERS.match_id = GAMES_IN_SCOPE.match_id AND OTHERS.at_home = GAMES_IN_SCOPE.target_at_home)
RIGHT JOIN players AS P ON P.id = OTHERS.player_id 
GROUP BY P.name, P.url, P.id
HAVING SUM(CASE WHEN LEAST(OTHERS.last_minute, t_last_min) - GREATEST(OTHERS.first_minute, t_first_min)> 0 THEN LEAST(OTHERS.last_minute, t_last_min) - GREATEST(OTHERS.first_minute, t_first_min) ELSE 0 END) > 0
ORDER BY shared_minutes DESC
LIMIT 3500
`

type GetAllPlayersAndSharedMinsByIDRow struct {
	OtherPlayerID uuid.UUID
	SharedMinutes int64
}

func (q *Queries) GetAllPlayersAndSharedMinsByID(ctx context.Context, id uuid.UUID) ([]GetAllPlayersAndSharedMinsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlayersAndSharedMinsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPlayersAndSharedMinsByIDRow
	for rows.Next() {
		var i GetAllPlayersAndSharedMinsByIDRow
		if err := rows.Scan(&i.OtherPlayerID, &i.SharedMinutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTimeTopScorers = `-- name: GetAllTimeTopScorers :many
SELECT
    players.name as player_name,
    SUM(player_matches.goals) as total_goals,
    COUNT(*) as matches_played
FROM player_matches
INNER JOIN players ON player_matches.player_id = players.id
INNER JOIN league_matches ON league_matches.url = player_matches.match_url
INNER JOIN competitions ON league_matches.competition_id = competitions.id
GROUP BY players.id, player_name
ORDER BY total_goals DESC
LIMIT 50
`

type GetAllTimeTopScorersRow struct {
	PlayerName    string
	TotalGoals    int64
	MatchesPlayed int64
}

func (q *Queries) GetAllTimeTopScorers(ctx context.Context) ([]GetAllTimeTopScorersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTimeTopScorers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTimeTopScorersRow
	for rows.Next() {
		var i GetAllTimeTopScorersRow
		if err := rows.Scan(&i.PlayerName, &i.TotalGoals, &i.MatchesPlayed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueAllTimeTopScorers = `-- name: GetLeagueAllTimeTopScorers :many
SELECT
    players.name as player_name,
    SUM(player_matches.goals) as total_goals,
    COUNT(*) as matches_played,
    competitions.name as competition_name
FROM player_matches
INNER JOIN players ON player_matches.player_id = players.id
INNER JOIN league_matches ON league_matches.url = player_matches.match_url
INNER JOIN competitions ON league_matches.competition_id = competitions.id
GROUP BY player_name, players.id, competition_name
ORDER BY total_goals DESC
LIMIT 50
`

type GetLeagueAllTimeTopScorersRow struct {
	PlayerName      string
	TotalGoals      int64
	MatchesPlayed   int64
	CompetitionName string
}

func (q *Queries) GetLeagueAllTimeTopScorers(ctx context.Context) ([]GetLeagueAllTimeTopScorersRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeagueAllTimeTopScorers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeagueAllTimeTopScorersRow
	for rows.Next() {
		var i GetLeagueAllTimeTopScorersRow
		if err := rows.Scan(
			&i.PlayerName,
			&i.TotalGoals,
			&i.MatchesPlayed,
			&i.CompetitionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesWhereMinsDontAddUp = `-- name: GetMatchesWhereMinsDontAddUp :many
SELECT
    match_url,
    SUM(last_minute - first_minute) AS squad_mins
FROM player_matches
GROUP BY match_id, match_url, at_home
HAVING SUM(last_minute - first_minute) < 990 AND SUM(red_card) < 1
ORDER BY squad_mins DESC
`

type GetMatchesWhereMinsDontAddUpRow struct {
	MatchUrl  string
	SquadMins int64
}

func (q *Queries) GetMatchesWhereMinsDontAddUp(ctx context.Context) ([]GetMatchesWhereMinsDontAddUpRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchesWhereMinsDontAddUp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchesWhereMinsDontAddUpRow
	for rows.Next() {
		var i GetMatchesWhereMinsDontAddUpRow
		if err := rows.Scan(&i.MatchUrl, &i.SquadMins); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfDistinctPlayersFieldedInLeagueByTeam = `-- name: GetNumberOfDistinctPlayersFieldedInLeagueByTeam :many
SELECT
    team_name,
    competition_name,
    COUNT(DISTINCT match_id) as matches_played,
    COUNT(DISTINCT player_id) as players_fielded
FROM(
SELECT
    PM.match_id as match_id,
    PM.player_id as player_id,
    HT.name as team_name,
    C.name as competition_name
FROM player_matches AS PM
INNER JOIN league_matches AS LM ON PM.match_id = LM.id
INNER JOIN teams AS HT ON HT.id = LM.home_team_id
INNER JOIN competitions AS C ON C.id = LM.competition_id
WHERE PM.at_home IS TRUE
GROUP BY team_name, competition_name, match_id, player_id
UNION ALL
SELECT
    PM.match_id as player_id,
    PM.player_id as player_id,
    AT.name as team_name,
    C.name as competition_name
FROM player_matches AS PM
INNER JOIN league_matches AS LM ON PM.match_id = LM.id
INNER JOIN teams AS AT ON AT.id = LM.away_team_id
INNER JOIN competitions AS C ON C.id = LM.competition_id
WHERE PM.at_home IS FALSE
GROUP BY team_name, competition_name, match_id, player_id
) s
GROUP BY team_name, competition_name
ORDER BY players_fielded DESC, matches_played DESC
`

type GetNumberOfDistinctPlayersFieldedInLeagueByTeamRow struct {
	TeamName        string
	CompetitionName string
	MatchesPlayed   int64
	PlayersFielded  int64
}

func (q *Queries) GetNumberOfDistinctPlayersFieldedInLeagueByTeam(ctx context.Context) ([]GetNumberOfDistinctPlayersFieldedInLeagueByTeamRow, error) {
	rows, err := q.db.QueryContext(ctx, getNumberOfDistinctPlayersFieldedInLeagueByTeam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNumberOfDistinctPlayersFieldedInLeagueByTeamRow
	for rows.Next() {
		var i GetNumberOfDistinctPlayersFieldedInLeagueByTeamRow
		if err := rows.Scan(
			&i.TeamName,
			&i.CompetitionName,
			&i.MatchesPlayed,
			&i.PlayersFielded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfGoalsScoredInEachLeagueSeasonByTeam = `-- name: GetNumberOfGoalsScoredInEachLeagueSeasonByTeam :many
SELECT
    team_name,
    competition_name,
    competition_season,
    SUM(goals_scored) as total_goals_scored,
    COUNT(DISTINCT match_id) as matches_played,
    COUNT(DISTINCT player_id) as players_fielded
FROM(
SELECT
    PM.match_id as match_id,
    PM.player_id as player_id,
    SUM(PM.goals) as goals_scored,
    HT.name as team_name,
    C.name as competition_name,
    C.season as competition_season
FROM player_matches AS PM
INNER JOIN league_matches AS LM ON PM.match_id = LM.id
INNER JOIN teams AS HT ON HT.id = LM.home_team_id
INNER JOIN competitions AS C ON C.id = LM.competition_id
WHERE PM.at_home IS TRUE
GROUP BY team_name, competition_name, competition_season, match_id, player_id
UNION ALL
SELECT
    PM.match_id as match_id,
    PM.player_id as player_id,
    SUM(PM.goals) as goals_scored,
    AT.name as team_name,
    C.name as competition_name,
    C.season as competition_season
FROM player_matches AS PM
INNER JOIN league_matches AS LM ON PM.match_id = LM.id
INNER JOIN teams AS AT ON AT.id = LM.away_team_id
INNER JOIN competitions AS C ON C.id = LM.competition_id
WHERE PM.at_home IS FALSE
GROUP BY team_name, competition_name, competition_season, match_id, player_id
) s
GROUP BY team_name, competition_name, competition_season
ORDER BY total_goals_scored DESC
`

type GetNumberOfGoalsScoredInEachLeagueSeasonByTeamRow struct {
	TeamName          string
	CompetitionName   string
	CompetitionSeason string
	TotalGoalsScored  int64
	MatchesPlayed     int64
	PlayersFielded    int64
}

func (q *Queries) GetNumberOfGoalsScoredInEachLeagueSeasonByTeam(ctx context.Context) ([]GetNumberOfGoalsScoredInEachLeagueSeasonByTeamRow, error) {
	rows, err := q.db.QueryContext(ctx, getNumberOfGoalsScoredInEachLeagueSeasonByTeam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNumberOfGoalsScoredInEachLeagueSeasonByTeamRow
	for rows.Next() {
		var i GetNumberOfGoalsScoredInEachLeagueSeasonByTeamRow
		if err := rows.Scan(
			&i.TeamName,
			&i.CompetitionName,
			&i.CompetitionSeason,
			&i.TotalGoalsScored,
			&i.MatchesPlayed,
			&i.PlayersFielded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerLeagueStats = `-- name: GetPlayerLeagueStats :many
SELECT
    players.name as player_name,
    SUM(player_matches.goals) as total_goals,
    COUNT(*) as matches_played,
    competitions.name as competition_name,
    competitions.season as competition_season
FROM player_matches
INNER JOIN players ON player_matches.player_id = players.id
INNER JOIN league_matches ON league_matches.url = player_matches.match_url
INNER JOIN competitions ON league_matches.competition_id = competitions.id
GROUP BY player_name, players.id, competition_name, competition_season
ORDER BY total_goals DESC
LIMIT 50
`

type GetPlayerLeagueStatsRow struct {
	PlayerName        string
	TotalGoals        int64
	MatchesPlayed     int64
	CompetitionName   string
	CompetitionSeason string
}

func (q *Queries) GetPlayerLeagueStats(ctx context.Context) ([]GetPlayerLeagueStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerLeagueStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerLeagueStatsRow
	for rows.Next() {
		var i GetPlayerLeagueStatsRow
		if err := rows.Scan(
			&i.PlayerName,
			&i.TotalGoals,
			&i.MatchesPlayed,
			&i.CompetitionName,
			&i.CompetitionSeason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerRecordsForGivenLeagueMatch = `-- name: GetPlayerRecordsForGivenLeagueMatch :many
SELECT
    players.name as player_name,
    player_matches.first_minute as first_minute,
    player_matches.last_minute as last_minute,
    CASE WHEN player_matches.at_home IS TRUE THEN HOME_T.name ELSE AWAY_T.name END AS team_name,
    player_matches.red_card as red_card,
    player_matches.yellow_card as yellow_card,
    player_matches.goals as goals,
    player_matches.penalties as pens,
    player_matches.own_goals as ogs
FROM player_matches
INNER JOIN players ON player_matches.player_id = players.id
INNER JOIN league_matches ON player_matches.match_id = league_matches.id
INNER JOIN teams AS HOME_T ON league_matches.home_team_id = HOME_T.id
INNER JOIN teams AS AWAY_T ON league_matches.away_team_id = AWAY_T.id
WHERE player_matches.match_url = $1
`

type GetPlayerRecordsForGivenLeagueMatchRow struct {
	PlayerName  string
	FirstMinute int32
	LastMinute  int32
	TeamName    interface{}
	RedCard     int32
	YellowCard  int32
	Goals       int32
	Pens        int32
	Ogs         int32
}

func (q *Queries) GetPlayerRecordsForGivenLeagueMatch(ctx context.Context, matchUrl string) ([]GetPlayerRecordsForGivenLeagueMatchRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerRecordsForGivenLeagueMatch, matchUrl)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerRecordsForGivenLeagueMatchRow
	for rows.Next() {
		var i GetPlayerRecordsForGivenLeagueMatchRow
		if err := rows.Scan(
			&i.PlayerName,
			&i.FirstMinute,
			&i.LastMinute,
			&i.TeamName,
			&i.RedCard,
			&i.YellowCard,
			&i.Goals,
			&i.Pens,
			&i.Ogs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersPlayedWithByUrl = `-- name: GetPlayersPlayedWithByUrl :many
SELECT
    P.name AS colleague_name,
    P.url AS player_url,
    P.id AS player_id,
    P.nationality AS colleague_nationality,
    SUM(CASE WHEN LEAST(OTHERS.last_minute, t_last_min) - GREATEST(OTHERS.first_minute, t_first_min)> 0 THEN LEAST(OTHERS.last_minute, t_last_min) - GREATEST(OTHERS.first_minute, t_first_min) ELSE 0 END) as total_mins_played
FROM (
SELECT
    match_id,
    at_home AS target_at_home,
    first_minute AS t_first_min,
    last_minute AS t_last_min
FROM player_matches
INNER JOIN players ON players.id = player_matches.player_id
WHERE players.url = $1
) AS GAMES_IN_SCOPE
INNER JOIN player_matches AS OTHERS ON (OTHERS.match_id = GAMES_IN_SCOPE.match_id AND OTHERS.at_home = GAMES_IN_SCOPE.target_at_home)
INNER JOIN players AS P ON P.id = OTHERS.player_id 
GROUP BY P.name, P.url, P.id
ORDER BY total_mins_played DESC
`

type GetPlayersPlayedWithByUrlRow struct {
	ColleagueName        string
	PlayerUrl            string
	PlayerID             uuid.UUID
	ColleagueNationality string
	TotalMinsPlayed      int64
}

func (q *Queries) GetPlayersPlayedWithByUrl(ctx context.Context, url string) ([]GetPlayersPlayedWithByUrlRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayersPlayedWithByUrl, url)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayersPlayedWithByUrlRow
	for rows.Next() {
		var i GetPlayersPlayedWithByUrlRow
		if err := rows.Scan(
			&i.ColleagueName,
			&i.PlayerUrl,
			&i.PlayerID,
			&i.ColleagueNationality,
			&i.TotalMinsPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsForPlayerUrl = `-- name: GetStatsForPlayerUrl :one
SELECT
    players.name as player_name,
    SUM(last_minute - first_minute) AS total_mins_played,
    COUNT(*) AS matches_played,
    SUM(goals) AS total_goals,
    SUM(penalties) AS total_pens,
    SUM(own_goals) AS total_ogs,
    SUM(yellow_card) AS total_yellow_card,
    SUM(red_card) AS total_red_card
FROM player_matches
INNER JOIN players ON players.id = player_matches.player_id
WHERE players.url = $1
GROUP BY player_name, players.id
`

type GetStatsForPlayerUrlRow struct {
	PlayerName      string
	TotalMinsPlayed int64
	MatchesPlayed   int64
	TotalGoals      int64
	TotalPens       int64
	TotalOgs        int64
	TotalYellowCard int64
	TotalRedCard    int64
}

func (q *Queries) GetStatsForPlayerUrl(ctx context.Context, url string) (GetStatsForPlayerUrlRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsForPlayerUrl, url)
	var i GetStatsForPlayerUrlRow
	err := row.Scan(
		&i.PlayerName,
		&i.TotalMinsPlayed,
		&i.MatchesPlayed,
		&i.TotalGoals,
		&i.TotalPens,
		&i.TotalOgs,
		&i.TotalYellowCard,
		&i.TotalRedCard,
	)
	return i, err
}

const getUrlsToRescrape = `-- name: GetUrlsToRescrape :many
SELECT LM.url, LM.home_team_online_id, LM.away_team_online_id
FROM league_matches AS LM
INNER JOIN player_matches AS PM ON PM.match_id = LM.id
GROUP BY PM.match_id, LM.url, LM.home_team_online_id, LM.away_team_online_id
HAVING SUM(PM.last_minute - PM.first_minute) < 1980
ORDER BY LM.url
`

type GetUrlsToRescrapeRow struct {
	Url              string
	HomeTeamOnlineID string
	AwayTeamOnlineID string
}

func (q *Queries) GetUrlsToRescrape(ctx context.Context) ([]GetUrlsToRescrapeRow, error) {
	rows, err := q.db.QueryContext(ctx, getUrlsToRescrape)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUrlsToRescrapeRow
	for rows.Next() {
		var i GetUrlsToRescrapeRow
		if err := rows.Scan(&i.Url, &i.HomeTeamOnlineID, &i.AwayTeamOnlineID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
