// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: competitions.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const checkIfCompetitionExistsById = `-- name: CheckIfCompetitionExistsById :one
SELECT EXISTS (SELECT 1
FROM competitions
WHERE id = $1
LIMIT 1)
`

func (q *Queries) CheckIfCompetitionExistsById(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfCompetitionExistsById, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkIfCompetitionExistsByNameAndSeason = `-- name: CheckIfCompetitionExistsByNameAndSeason :one
SELECT EXISTS (SELECT 1
FROM competitions
WHERE name = $1 AND season = $2
LIMIT 1)
`

type CheckIfCompetitionExistsByNameAndSeasonParams struct {
	Name   string
	Season string
}

func (q *Queries) CheckIfCompetitionExistsByNameAndSeason(ctx context.Context, arg CheckIfCompetitionExistsByNameAndSeasonParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfCompetitionExistsByNameAndSeason, arg.Name, arg.Season)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCompetition = `-- name: CreateCompetition :one
INSERT INTO competitions (id, name, season, url)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, name, season, url
`

type CreateCompetitionParams struct {
	ID     uuid.UUID
	Name   string
	Season string
	Url    string
}

func (q *Queries) CreateCompetition(ctx context.Context, arg CreateCompetitionParams) (Competition, error) {
	row := q.db.QueryRowContext(ctx, createCompetition,
		arg.ID,
		arg.Name,
		arg.Season,
		arg.Url,
	)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Season,
		&i.Url,
	)
	return i, err
}

const deleteCompetitions = `-- name: DeleteCompetitions :exec
DELETE FROM competitions
`

func (q *Queries) DeleteCompetitions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCompetitions)
	return err
}

const getAllClubCompetitionResults = `-- name: GetAllClubCompetitionResults :many
SELECT 
    team_name,
    competition_name,
    competition_season,
    SUM(goals_scored) AS goals_scored,
    SUM(goals_conceded) AS goals_conceded,
    SUM(goal_difference) AS goal_difference,
    SUM(games_played) AS games_played,
    SUM(wins) AS wins,
    SUM(draws) AS draws,
    SUM(losses) AS losses,
    SUM(points) AS points
FROM(
SELECT 
    teams.name AS team_name,
    competitions.id AS competition_id,
    competitions.name AS competition_name,
    competitions.season AS competition_season,
    SUM(matches.home_goals) AS goals_scored,
    SUM(matches.away_goals) AS goals_conceded,
    COUNT(*) AS games_played,
    SUM(matches.home_goals) - SUM(matches.away_goals) AS goal_difference,
    SUM(CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END) AS draws,
    SUM(CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END) AS losses,
    SUM((CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END)*3 + (CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END)) AS points
FROM teams
INNER JOIN matches ON matches.home_team_id = teams.id
INNER JOIN competitions ON matches.competition_id = competitions.id
WHERE teams.name = $1
GROUP BY competitions.id, teams.name, competitions.name, competitions.season
UNION ALL
SELECT 
    teams.name AS team_name,
    competitions.id AS competition_id,
    competitions.name AS competition_name,
    competitions.season AS competition_season,
    SUM(matches.away_goals) AS goals_scored,
    SUM(matches.home_goals) AS goals_conceded,
    COUNT(*) AS games_played,
    SUM(matches.away_goals) - SUM(matches.home_goals) AS goal_difference,
    SUM(CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END) AS draws,
    SUM(CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END) AS losses,
    SUM((CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END)*3 + (CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END)) AS points
FROM teams
INNER JOIN matches ON matches.away_team_id = teams.id
INNER JOIN competitions ON matches.competition_id = competitions.id
WHERE teams.name = $1
GROUP BY competitions.id, teams.name, competitions.name, competitions.season
) s
GROUP BY competition_id, team_name, competition_name, competition_season
ORDER BY points DESC, goal_difference DESC, goals_scored DESC, goals_conceded DESC, wins DESC
`

type GetAllClubCompetitionResultsRow struct {
	TeamName          string
	CompetitionName   string
	CompetitionSeason string
	GoalsScored       int64
	GoalsConceded     int64
	GoalDifference    int64
	GamesPlayed       int64
	Wins              int64
	Draws             int64
	Losses            int64
	Points            int64
}

func (q *Queries) GetAllClubCompetitionResults(ctx context.Context, name string) ([]GetAllClubCompetitionResultsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllClubCompetitionResults, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClubCompetitionResultsRow
	for rows.Next() {
		var i GetAllClubCompetitionResultsRow
		if err := rows.Scan(
			&i.TeamName,
			&i.CompetitionName,
			&i.CompetitionSeason,
			&i.GoalsScored,
			&i.GoalsConceded,
			&i.GoalDifference,
			&i.GamesPlayed,
			&i.Wins,
			&i.Draws,
			&i.Losses,
			&i.Points,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTimeCompetitionTable = `-- name: GetAllTimeCompetitionTable :many
SELECT 
    team_name,
    SUM(goals_scored) AS goals_scored,
    SUM(goals_conceded) AS goals_conceded,
    SUM(goal_difference) AS goal_difference,
    SUM(games_played) AS games_played,
    SUM(wins) AS wins,
    SUM(draws) AS draws,
    SUM(losses) AS losses,
    SUM(points) AS points
FROM(
SELECT 
    teams.name AS team_name,
    SUM(matches.home_goals) AS goals_scored,
    SUM(matches.away_goals) AS goals_conceded,
    COUNT(*) AS games_played,
    SUM(matches.home_goals) - SUM(matches.away_goals) AS goal_difference,
    SUM(CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END) AS draws,
    SUM(CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END) AS losses,
    SUM((CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END)*3 + (CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END)) AS points
FROM teams
INNER JOIN matches ON matches.home_team_id = teams.id
INNER JOIN competitions ON matches.competition_id = competitions.id
WHERE competitions.name = $1
GROUP BY team_name
UNION ALL
SELECT 
    teams.name AS team_name,
    SUM(matches.away_goals) AS goals_scored,
    SUM(matches.home_goals) AS goals_conceded,
    COUNT(*) AS games_played,
    SUM(matches.away_goals) - SUM(matches.home_goals) AS goal_difference,
    SUM(CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END) AS draws,
    SUM(CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END) AS losses,
    SUM((CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END)*3 + (CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END)) AS points
FROM teams
INNER JOIN matches ON matches.away_team_id = teams.id
INNER JOIN competitions ON matches.competition_id = competitions.id
WHERE competitions.name = $1
GROUP BY team_name
) s
GROUP BY team_name
ORDER BY points DESC, goal_difference DESC, goals_scored DESC, goals_conceded DESC, wins DESC
`

type GetAllTimeCompetitionTableRow struct {
	TeamName       string
	GoalsScored    int64
	GoalsConceded  int64
	GoalDifference int64
	GamesPlayed    int64
	Wins           int64
	Draws          int64
	Losses         int64
	Points         int64
}

func (q *Queries) GetAllTimeCompetitionTable(ctx context.Context, name string) ([]GetAllTimeCompetitionTableRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTimeCompetitionTable, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTimeCompetitionTableRow
	for rows.Next() {
		var i GetAllTimeCompetitionTableRow
		if err := rows.Scan(
			&i.TeamName,
			&i.GoalsScored,
			&i.GoalsConceded,
			&i.GoalDifference,
			&i.GamesPlayed,
			&i.Wins,
			&i.Draws,
			&i.Losses,
			&i.Points,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompetitionIdFromNameAndSeason = `-- name: GetCompetitionIdFromNameAndSeason :one
SELECT id
FROM competitions
WHERE name = $1 AND season = $2
`

type GetCompetitionIdFromNameAndSeasonParams struct {
	Name   string
	Season string
}

func (q *Queries) GetCompetitionIdFromNameAndSeason(ctx context.Context, arg GetCompetitionIdFromNameAndSeasonParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getCompetitionIdFromNameAndSeason, arg.Name, arg.Season)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getCompetitionNameAndSeasonFromId = `-- name: GetCompetitionNameAndSeasonFromId :one
SELECT name, season
FROM competitions
WHERE id = $1
`

type GetCompetitionNameAndSeasonFromIdRow struct {
	Name   string
	Season string
}

func (q *Queries) GetCompetitionNameAndSeasonFromId(ctx context.Context, id uuid.UUID) (GetCompetitionNameAndSeasonFromIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCompetitionNameAndSeasonFromId, id)
	var i GetCompetitionNameAndSeasonFromIdRow
	err := row.Scan(&i.Name, &i.Season)
	return i, err
}

const getCompetitionTable = `-- name: GetCompetitionTable :many
SELECT 
    team_name,
    SUM(goals_scored) AS goals_scored,
    SUM(goals_conceded) AS goals_conceded,
    SUM(goal_difference) AS goal_difference,
    SUM(games_played) AS games_played,
    SUM(wins) AS wins,
    SUM(draws) AS draws,
    SUM(losses) AS losses,
    SUM(points) AS points
FROM(
SELECT 
    teams.name AS team_name,
    SUM(matches.home_goals) AS goals_scored,
    SUM(matches.away_goals) AS goals_conceded,
    COUNT(*) AS games_played,
    SUM(matches.home_goals) - SUM(matches.away_goals) AS goal_difference,
    SUM(CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END) AS draws,
    SUM(CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END) AS losses,
    SUM((CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END)*3 + (CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END)) AS points
FROM teams
INNER JOIN matches ON matches.home_team_id = teams.id
INNER JOIN competitions ON matches.competition_id = competitions.id
WHERE competitions.name = $1 AND competitions.season = $2
GROUP BY team_name
UNION ALL
SELECT 
    teams.name AS team_name,
    SUM(matches.away_goals) AS goals_scored,
    SUM(matches.home_goals) AS goals_conceded,
    COUNT(*) AS games_played,
    SUM(matches.away_goals) - SUM(matches.home_goals) AS goal_difference,
    SUM(CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END) AS draws,
    SUM(CASE WHEN home_goals>away_goals THEN 1 ELSE 0 END) AS losses,
    SUM((CASE WHEN home_goals<away_goals THEN 1 ELSE 0 END)*3 + (CASE WHEN home_goals=away_goals THEN 1 ELSE 0 END)) AS points
FROM teams
INNER JOIN matches ON matches.away_team_id = teams.id
INNER JOIN competitions ON matches.competition_id = competitions.id
WHERE competitions.name = $1 AND competitions.season = $2
GROUP BY team_name
) s
GROUP BY team_name
ORDER BY points DESC, goal_difference DESC, goals_scored DESC, goals_conceded DESC, wins DESC
`

type GetCompetitionTableParams struct {
	Name   string
	Season string
}

type GetCompetitionTableRow struct {
	TeamName       string
	GoalsScored    int64
	GoalsConceded  int64
	GoalDifference int64
	GamesPlayed    int64
	Wins           int64
	Draws          int64
	Losses         int64
	Points         int64
}

func (q *Queries) GetCompetitionTable(ctx context.Context, arg GetCompetitionTableParams) ([]GetCompetitionTableRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitionTable, arg.Name, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompetitionTableRow
	for rows.Next() {
		var i GetCompetitionTableRow
		if err := rows.Scan(
			&i.TeamName,
			&i.GoalsScored,
			&i.GoalsConceded,
			&i.GoalDifference,
			&i.GamesPlayed,
			&i.Wins,
			&i.Draws,
			&i.Losses,
			&i.Points,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueCompetitionSeasons = `-- name: GetUniqueCompetitionSeasons :many
SELECT name, season
FROM competitions
`

type GetUniqueCompetitionSeasonsRow struct {
	Name   string
	Season string
}

func (q *Queries) GetUniqueCompetitionSeasons(ctx context.Context) ([]GetUniqueCompetitionSeasonsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUniqueCompetitionSeasons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUniqueCompetitionSeasonsRow
	for rows.Next() {
		var i GetUniqueCompetitionSeasonsRow
		if err := rows.Scan(&i.Name, &i.Season); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
