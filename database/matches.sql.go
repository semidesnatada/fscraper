// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: matches.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (id, competition_id, home_team_id, away_team_id,
home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
)
RETURNING id, competition_id, home_team_id, away_team_id, home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url
`

type CreateMatchParams struct {
	ID            uuid.UUID
	CompetitionID uuid.UUID
	HomeTeamID    uuid.UUID
	AwayTeamID    uuid.UUID
	HomeGoals     int32
	AwayGoals     int32
	Date          time.Time
	KickOffTime   sql.NullTime
	RefereeID     uuid.NullUUID
	VenueID       uuid.NullUUID
	Attendance    sql.NullInt32
	HomeXg        sql.NullFloat64
	AwayXg        sql.NullFloat64
	Weekday       string
	Url           string
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch,
		arg.ID,
		arg.CompetitionID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.HomeGoals,
		arg.AwayGoals,
		arg.Date,
		arg.KickOffTime,
		arg.RefereeID,
		arg.VenueID,
		arg.Attendance,
		arg.HomeXg,
		arg.AwayXg,
		arg.Weekday,
		arg.Url,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeGoals,
		&i.AwayGoals,
		&i.Date,
		&i.KickOffTime,
		&i.RefereeID,
		&i.VenueID,
		&i.Attendance,
		&i.HomeXg,
		&i.AwayXg,
		&i.Weekday,
		&i.Url,
	)
	return i, err
}

const deleteMatches = `-- name: DeleteMatches :exec
DELETE FROM matches
`

func (q *Queries) DeleteMatches(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteMatches)
	return err
}

const getGamesByTeamAndSeason = `-- name: GetGamesByTeamAndSeason :many
SELECT 
HT.name as home_team, 
AT.name as away_team, 
M.home_goals as home_goals, 
M.away_goals as away_goals,
M.date as date,
venues.name as stadium
FROM matches as M
INNER JOIN teams as HT on HT.id = M.home_team_id
INNER JOIN teams as AT on AT.id = M.away_team_id
INNER JOIN competitions on competitions.id = M.competition_id
INNER JOIN venues on M.venue_id = venues.id
WHERE (HT.name = $1 OR AT.name = $1) AND competitions.name = $2 AND competitions.season = $3
`

type GetGamesByTeamAndSeasonParams struct {
	Name   string
	Name_2 string
	Season string
}

type GetGamesByTeamAndSeasonRow struct {
	HomeTeam  string
	AwayTeam  string
	HomeGoals int32
	AwayGoals int32
	Date      time.Time
	Stadium   string
}

func (q *Queries) GetGamesByTeamAndSeason(ctx context.Context, arg GetGamesByTeamAndSeasonParams) ([]GetGamesByTeamAndSeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, getGamesByTeamAndSeason, arg.Name, arg.Name_2, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGamesByTeamAndSeasonRow
	for rows.Next() {
		var i GetGamesByTeamAndSeasonRow
		if err := rows.Scan(
			&i.HomeTeam,
			&i.AwayTeam,
			&i.HomeGoals,
			&i.AwayGoals,
			&i.Date,
			&i.Stadium,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatches = `-- name: GetMatches :many
SELECT id, competition_id, home_team_id, away_team_id, home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url FROM matches
`

func (q *Queries) GetMatches(ctx context.Context) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, getMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeGoals,
			&i.AwayGoals,
			&i.Date,
			&i.KickOffTime,
			&i.RefereeID,
			&i.VenueID,
			&i.Attendance,
			&i.HomeXg,
			&i.AwayXg,
			&i.Weekday,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByClub = `-- name: GetMatchesByClub :many
SELECT id, competition_id, home_team_id, away_team_id, home_goals, away_goals, date, kick_off_time, referee_id, venue_id, attendance, home_xg, away_xg, weekday, url FROM matches
WHERE home_team_id = $1 or away_team_id = $1
`

func (q *Queries) GetMatchesByClub(ctx context.Context, homeTeamID uuid.UUID) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, getMatchesByClub, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeGoals,
			&i.AwayGoals,
			&i.Date,
			&i.KickOffTime,
			&i.RefereeID,
			&i.VenueID,
			&i.Attendance,
			&i.HomeXg,
			&i.AwayXg,
			&i.Weekday,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
